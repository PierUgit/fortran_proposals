To: J3                                                     J3/24-xxx
From: Pierre Hugonnet
Subject: allow complex pointer to real target and vice versa
         use cases and formal requirements
Date: 2024-xxxx-xx
#Reference:

1. Introduction

At the 24-28 June 2024 meeting, J3 and WG5 have accepted the preliminary
proposal 24-129 to allow a complex pointer to be associated with a real 
target and vice-versa.

This paper elaborates on the use cases and the formal requirements.

2. Use cases

2.1 3D convolution by FFT

Consider a code that performs a 3D FFT based convolution at some point, 
written in a fully standard-conforming way:

    program foo
    use some_module, only :: read_data, write_data
    real, allocatable :: D(:,:,:), P(:,:,:), M(:,:,:)
    
    real, parameter :: alpha = 0.8
    real, allocatable :: x(:)
    integer :: n(3), j1, j2, j3
    
    !> Read the data into D and P
    call read_data(D,P)
    n = shape(D)
    
    !> do some preprocessing on the real samples
    x = [( exp(-j1*alpha), j1=0,n(1)-1)]
    do l = 1, n(3)
       do l = 1, n(2)
          D(:,i2,i3) = D(:,i2,i2) * x(:)
          P(:,i2,i3) = P(:,i2,i2) * x(:)
       end do
    end do
    
    !> 3D convolution in the Fourier domain, using intermediate 
    !> complex arrays and real-to-complex direct and inverse 3D ffts
    allocate( cD(0:n(1)/2,n(2),n(3)) )
    allocate( CP, cM, mold=cD )
    call rcfft3d(D,cD) ; call rcfft3d(P,cP)
    cM = cD * cP
    call crfft(M,cM)
    
    !> do some postprocessing on the real samples
    x(:) = 1.0 / x(:)
    do l = 1, n(3)
       do l = 1, n(2)
          M(:,i2,i3) = M(:,i2,i2) * x(:)
       end do
    end do

    call write_data(M)
    
    end program

This use case is not hypothetical, it's a very simplified version of a
some typical code from seismic data processing (geophysics).

In practice nobody does write the code like above in a HPC context, as 
it requires twice the amount of RAM (with also some consequences on the 
volumes transfered between the RAM and the CPU cores). The classical 
solution was to call a dangling routine (without any interface), 
pass real actual arguments to complex dummy arguments, and perform
in-place FFTs. This works in practice because all compilers do store a
complex number as the pair (real part, imaginary part) in this order in
memory. Nonetheless this is formally a violation of the standard:

    !> 3D convolution in the Fourier domain with in-places FFTs
    !> The real array must have been dimensioned directly with
    !> FFT compatible sizes
    call rcfft3d(D) ; call rcfft3d(P)
    call fourier_convolution(D,P,M,shape(D))
    call crfft(M)
...
    ! dangling routine (not contained and not in a module)
    subroutine fourier_convolution(X,Y,Z,n)
    integer, intent(in) :: n(3)
    complex, intent(in)  :: X(n(1)/2,n(2),n(3)), Y(n(1)/2,n(2),n(3))
    complex, intent(out) :: Z(n(1)/2,n(2),n(3))
    Z(:) = X(:) * Y(:)
    end subroutine

With modern Fortran another trick has got quite popular, by using the 
c_f_pointer() and c_loc() functions of the C interoperability features.
This trick is even mentioned in the official documentation of FFTW, 
which is one of the most popular FFT library [1], but this is non
standard as well.

If it was possible to get a complex pointer to a real array, and
provided that the de facto standard used by all the compilers to store
a complex number be standardized, the above code could be written
without duplicating the arrays and be still be standard conforming.

2.2 Complex dot product with a real result

When computing a dot product between two complex arrays, one sometimes 
know that the result is supposed to be real, such that it useless to 
compute the imaginary part of the result. Typically this was (and still 
is) achieved by calling the SDOT (or DDOT) BLAS functions with the 
complex arrays as actual arguments (and twice the size), hence with a 
non-conforming type mismatch. Using the intrinsic DOT_PRODUCT function 
this way is not possible because the compilers enforce the type 
conformance.

Again, if it was possible to get a real pointer to a complex array, it 
would be possible to be fully standard conforming.

3. Formal Requirements

r1. There shall be a mechanism to provide a complex view of a contiguous 
    real array, and a real view of a contiguous complex array.

r2. A view of an array shall itself be an array (of COMPLEX type if it 
    is a complex view, or of REAL type if it a real view).
   
r3. A view of an array shall have the same kind as the array.

r4. A view of an array shall not own the memory.

r5. Referencing the real part of the i-th storage unit of a complex view
    of a real array shall be equivalent to referencing the (2*i-1)-th 
    storage unit of the real array.

r6. Referencing the imaginary part of the i-th storage unit of a complex
    view of a real array shall be equivalent to referencing the (2*i)-th
    storage unit of the real array.

r7. Referencing the (2*i-1)-th storage unit of a real view to a complex 
    array shall be equivalent to referencing the real part of the i-th 
    storage unit of the complex array.
   
r8. Referencing the (2*i)-th storage unit of a real view to a complex 
    array shall be equivalent to referencing the imaginary part of the 
    i-th storage unit of the complex array.
